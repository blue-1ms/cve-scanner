import socket
import ipaddress
import json
import threading
from queue import Queue
import nmap
import requests
import tkinter as tk
from tkinter import messagebox, filedialog
import schedule
import time
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

# Function to automatically discover the local network range
def get_local_network():
    hostname = socket.gethostname()
    local_ip = socket.gethostbyname(hostname)
    network = '.'.join(local_ip.split('.')[:-1]) + '.0/24'
    return network

# Function to scan the network
def scan_network(network):
    active_hosts = []
    for ip in ipaddress.IPv4Network(network):
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(1)
            result = sock.connect_ex((str(ip), 80))  # Check if port 80 is open
            if result == 0:
                active_hosts.append(str(ip))
            sock.close()
        except Exception as e:
            print(f"Error scanning {ip}: {e}")
    return active_hosts

# Function to scan ports using nmap for detailed service detection
def scan_ports_nmap(host, port_range):
    nm = nmap.PortScanner()
    scan_data = nm.scan(hosts=host, ports=f"{min(port_range)}-{max(port_range)}", arguments='-sV')
    open_ports = {}
    for proto in scan_data['scan'][host].all_protocols():
        lport = scan_data['scan'][host][proto].keys()
        for port in lport:
            service = scan_data['scan'][host][proto][port]['name']
            version = scan_data['scan'][host][proto][port]['version']
            open_ports[port] = {'service': service, 'version': version}
    return open_ports

# Function to fetch CVE data for a given service/version
def fetch_cve_data(service, version):
    cve_url = f"https://services.nvd.nist.gov/rest/json/cves/1.0?keyword={service}%20{version}"
    response = requests.get(cve_url)
    if response.status_code == 200:
        cve_data = response.json()
        return cve_data.get('result', {}).get('CVE_Items', [])
    else:
        print(f"Error fetching CVE data: {response.status_code}")
        return []

# Function to check for vulnerabilities based on CVE data
def check_vulnerabilities(host, open_ports):
    vulnerabilities = []
    for port, service_info in open_ports.items():
        cve_list = fetch_cve_data(service_info['service'], service_info['version'])
        for cve in cve_list:
            vuln = {
                'cve_id': cve['cve']['CVE_data_meta']['ID'],
                'description': cve['cve']['description']['description_data'][0]['value']
            }
            vulnerabilities.append(f"Vulnerability found on port {port}: {vuln['cve_id']} - {vuln['description']}")
    return vulnerabilities

# Function to save the scan results to a file
def save_report(hosts, filename, format='json'):
    if format == 'json':
        with open(filename, 'w') as file:
            json.dump(hosts, file, indent=4)
    elif format == 'text':
        with open(filename, 'w') as file:
            for host, data in hosts.items():
                file.write(f"Host: {host}\n")
                for port, service in data['open_ports'].items():
                    file.write(f"Port {port}: {service['service']} {service['version']}\n")
                if 'vulnerabilities' in data:
                    file.write("Vulnerabilities:\n")
                    for vuln in data['vulnerabilities']:
                        file.write(f"- {vuln}\n")

# Function to send email notifications
def send_email_report(subject, body, to_email):
    from_email = "your_email@example.com"
    password = "your_password"
    
    msg = MIMEMultipart()
    msg['From'] = from_email
    msg['To'] = to_email
    msg['Subject'] = subject
    
    msg.attach(MIMEText(body, 'plain'))
    
    try:
        server = smtplib.SMTP('smtp.gmail.com', 587)
        server.starttls()
        server.login(from_email, password)
        text = msg.as_string()
        server.sendmail(from_email, to_email, text)
        server.quit()
        print("Email sent successfully!")
    except Exception as e:
        print(f"Failed to send email: {e}")

# GUI Setup
def start_scan():
    network = network_entry.get()
    scan_type = scan_type_var.get()

    if scan_type == 'quick':
        port_range = range(1, 1024)
    elif scan_type == 'full':
        port_range = range(1, 65535)
    elif scan_type == 'custom':
        custom_ports = custom_port_entry.get()
        port_range = range(int(custom_ports.split('-')[0]), int(custom_ports.split('-')[1]) + 1)

    active_hosts = scan_network(network)
    scan_results = {}

    if active_hosts:
        for host in active_hosts:
            open_ports = scan_ports_nmap(host, port_range)
            vulnerabilities = check_vulnerabilities(host, open_ports)
            scan_results[host] = {'open_ports': open_ports, 'vulnerabilities': vulnerabilities}

        # Save the scan results to a file
        output_format = 'json'  # default to JSON format
        file_path = filedialog.asksaveasfilename(defaultextension=".json", filetypes=[("JSON files", "*.json"), ("Text files", "*.txt")])
        if file_path:
            save_report(scan_results, file_path, format=output_format)

        # Display results in a popup window
        result_text = json.dumps(scan_results, indent=4)
        result_window = tk.Toplevel()
        result_window.title("Scan Results")
        result_label = tk.Label(result_window, text=result_text)
        result_label.pack()
        
        # Optional: Send email
        send_email = messagebox.askyesno("Send Report", "Do you want to send the report via email?")
        if send_email:
            recipient_email = recipient_email_entry.get()
            email_subject = "Network Penetration Test Results"
            send_email_report(email_subject, result_text, recipient_email)

    else:
        messagebox.showinfo("No Hosts Found", "No active hosts found on the network.")

def schedule_scan():
    schedule.every().day.at("02:00").do(start_scan)
    while True:
        schedule.run_pending()
        time.sleep(1)

root = tk.Tk()
root.title("Network Penetration Testing Tool")

# Network Entry
tk.Label(root, text="Network Range:").grid(row=0, column=0)
network_entry = tk.Entry(root)
network_entry.grid(row=0, column=1)

# Scan Type Options
scan_type_var = tk.StringVar(value="quick")
tk.Label(root, text="Scan Type:").grid(row=1, column=0)
tk.Radiobutton(root, text="Quick Scan", variable=scan_type_var, value="quick").grid(row=1, column=1)
tk.Radiobutton(root, text="Full Scan", variable=scan_type_var, value="full").grid(row=1, column=2)
tk.Radiobutton(root, text="Custom Scan", variable=scan_type_var, value="custom").grid(row=1, column=3)

# Custom Port Range Entry
custom_port_entry = tk.Entry(root)
custom_port_entry.grid(row=2, column=1)
custom_port_entry.insert(0, "20-80")  # Default custom range

# Email recipient entry
tk.Label(root, text="Recipient Email (optional):").grid(row=3, column=0)
recipient_email_entry = tk.Entry(root)
recipient_email_entry.grid(row=3, column=1)

# Start Button
tk.Button(root, text="Start Scan", command=start_scan).grid(row=4, column=0, columnspan=2)

# Schedule Scan Button
tk.Button(root, text="Schedule Daily Scan at 2 AM", command=schedule_scan).grid(row=5, column=0, columnspan=2)

root.mainloop()
